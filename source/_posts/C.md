---
title: C
date: 2018-06-26 10:22:06
tags: [C11]
---

# 简介

C语言是一门很接近底层的过程性高级编程语言，是高性能计算的主要选择，例如：系统编程。

<!--more-->

# 开发环境

## 安装

### 静态代码分析工具

lint/splint

### IDE

Windows：Visual Studio

OS X：Xcode

其他：Eclipse CDT、CLion、Code::Blocks、KDevelop

在配置IDE时，很重要的是配置includePath。可以使用下面命令来查看gcc的includePath：

```bash
$ echo | gcc -v -x c -E -
```

上面是查看C语言的includePath，如果要查看C++，则只需要将上面的“c”改成“c++”。

## 交互模式

无 

## 解释模式

无

## 编译模式

C的编译器可以选择gcc，也可以选择clang。

安装好gcc或clang后，可以将它们链接到名为cc（通常放在`/usr/bin/cc`）的默认编译器。

可以通过下面命令来查看编译器的版本：

```bash
$ cc --version
$ gcc --version
$ clang --version
```

可以使用下列命令将`hello.c`编译成可执行文件`hello`：

```bash
$ cc hello.c -o hello -g -Wall -O3
```

如果省略`-o hello`，则生成可执行文件名为`a.out`（Windows下为`a.exe`）。

`-Wall`要求编译器输出警告信息，默认只有错误信息才会输出。

`-O3`表示采用三级优化等级。

`-g`表示在目标文件和可执行文件中包含符号表和源代码行号信息。

使用`-save-temps`选项，会将整个构建过程中产生的中间文件全部输出：

```bash
$ gcc -o hello hello.c -save-temps
```

上述命令将生成：`hello`、`hello.i`、`hello.o`和`hello.s`。

另外，可以使用选项`-std`来指定采用哪一种C语言定义。

GCC的语言标准化选项：

- `-std=iso9899:1990`、`-std=c90`、`-std=c89`或`-ansi`：遵循ISO/IEC 9899:1990。
- `-std=iso9899:199409`：遵循“AMDI”，这是1995针对ISO/IEC 9899:1990的国际化修正。
- `-std=iso9899:1999`、`-std=c99`：遵循ISO/IEC 9899:1999，以及2001年的技术勘误。
- `-std=iso9899:2011`、`-std=c11`：遵循ISO/IEC 9899:2011。
- `-std=gnu89`、`-std=gnu90`：支持ISO/IEC 9899:1990和GNU扩展内容。这是版本5之前的默认选项。
- `-std=gnu99`：支持ISO/IEC 9899:1999和GNU扩展内容。
- `-std=gnu11`：支持ISO/IEC 9899:2011和GNU扩展内容，但不具备C11标准中可选的多线程特性。这是版本5以后的默认选项。

接下来，将介绍如何分别生产每个阶段的中间文件。

如果只是想检测源文件的语法是否正确，而不执行预处理、编译、汇编或链接，则可以使用`-fsyntax-only`选项。

可以一次性编译多个源文件：

```bash
$ gcc -o foo foo.c bar.c
```

### 预处理

将源代码提交给编译器之前，由预处理器展开源代码文件中的宏。

可用下列命令查看预处理的结果：

```bash
$ gcc -E -C -o hello.i hello.c
```

> `-E`选项表示仅作预处理，不进行编译、汇编或链接。
>
> `-C` 选项在执行预处理时保留注释。

在命令中，可以使用`-D宏名[=定义]`方式来定义宏：

```bash
$ gcc hello.c -DFOO
```

省略“=定义”部分，则该宏被定义为值1。

宏`FOO`必须是在源文件和头文件中都没有被定义过的。

该选项经常搭配源代码中的`#ifdef`指令使用，可以实现条件式编译。

相应地，选项`-U宏名` 表示“取消”宏定义。

另外，还可以使用`-I`、`-iquote`、`-isystem`和`-isysroot`等选项来自定义头文件搜索路径。（参见预处理指令的“#include”部分）

### 编译

编译器的核心任务是把C程序翻译成机器的汇编语言。

下列命令可输出翻译的汇编语言文件`hello.s`：

```bash
$ gcc -S hello.c
```

> `-S`选项表示编译到汇编语言，不进行汇编和链接。

如果想把C语言变量的名称作为汇编语言语句中的注释，可以加上`-fverbose-asm`选项：

```bash
$ gcc -S -fverbose-asm hello.c
```

### 汇编

在汇编阶段，GCC调用宿主系统的汇编器，把汇编语言翻译成可执行的二进制代码，即输出一个目标文件。

可以使用下列命令输出目标文件`hello.o`：

```bash
$ gcc -c hello.c
```

> `-c`选项指示GCC只编译和汇编，不进行链接。

可以使用GCC的`-Wa,参数1,参数2,…`选项（参数可以有多个，之间使用逗号分隔）给汇编器传递参数：

```bash
$ gcc -v -o hello -Wa,-as=hello.sym,-L hello.c
```

`-v`：显示编译器调用的程序。

紧跟`-Wa`后面，以逗号开头，中间不能有空格的都是传递给汇编器的参数。`,-as=hello.sym`表示把符号表输出到`hello.sym`文件中。`,-L`表示在符号表中包含本地符号。本地符号指具有内部链接的C标识符。（不要把该汇编器选项与GCC的`-L`选项混淆！）

```bash
$ gcc -g -c -Wa,-a=hello.list,-L hello.c
```

如果没有带`-g`选项，则`hello.list`只会包含生成的二进制机器码及相应的汇编代码，然后后面再跟上符号表内容。则带上了`-g`选项后，还会将C代码插入到对应的二进制代码和汇编代码之间，从而允许逐行地查看编译器如何把C语句翻译为二进制机器码。

有一类反汇编器（disassembler），例如：objdump，可以查看目标文件。只需执行下列命令，就可输出二进制机器码及其对应的汇编代码：

```bash
$ objdump -d hello.o
```



### 链接

链接器把多个二进制目标文件链接成一个单独的可执行文件。

#### 链接顺序

在命令中，链接库要放在源文件之后。如果有多个链接库，则被依赖的库，要放在依赖它的库之后。例如：`foo.o`依赖于`bar1`库，而`bar1`库依赖于`bar2`库，则应该输入：

```bash
$ gcc foo.o -lbar1 -lbar2
```

任何其他顺序，比如`gcc -lbar1 -lbar2 foo.o`，都可能失败。链接器是按顺序搜索库的，它首先查看第一个目标`foo.o`，将无法解析的函数、结构和变量名记入一个列表。然后链接器查看下一个目标——`bar1`，并在这个目标内搜索列表中仍然缺失的项目，同时有可能在列表中添加新的项目；接着在`bar2`中查找仍然缺失的项目。如果直到搜索完最后的目标仍然存在未解析的符号（包括在最后的隐含的`-lc`），链接器将终止运行并向用户给出最后剩下的未解析项目。因此，如果顺序不对，有些项目将错过搜索它所在库的机会。

#### 链接库

链接库分为静态和动态两种。

静态链接库：当要**链接时**，链接器会找出程序所需的函数，然后将它们拷贝到执行文件中，由于这种拷贝是完整的，所以一旦链接成功，静态链接库也就不再需要了。

动态链接库（也称共享链接库）：它是一种特殊目标文件，它可以在**运行时**被链接到一个程序。因此，在运行时动态链接库必须在搜索路径中。

使用静态链接库生成的可执行文件，会明显比使用动态链接库生成的可执行文件大，而且内存使用效率也更低。

名为`foo`的链接库，它的静态链接库文件名必须是`libfoo.a`，即带上前缀`lib` 和后缀`.a`；而动态链接库文件名则以`lib` 为前缀，以`.so`或`.dylib` 为后缀。

创建静态链接库：

```bash
$ ar -cr libfoo.a foo.o bar.o
```

创建动态链接库：

```bash
$ gcc -shared -o libfoo.so foo.o bar.o
```

链接动态链接库和静态链接库的方式是一样的。

当搜索路径中同时存在同一个链接库的静态和动态版本时，gcc优先使用动态链接库。在这种情况下，可以使用`-static`选项来显式指示使用静态链接库：

```bash
$ gcc -static -o hello hello.o -lncurses
```

另一种显式指示使用静态链接库的方式是，在命令行中显示使用静态链接库文件，而不使用`-l`选项：

```bash
$ gcc -o hello hello.o /usr/lib/libncurses.a
```

#### 默认标准库

gcc在编译C代码时，会默认带上`-lc`选项，即默认链接标准库`c`。标准库的大部分函数通常放在静态链接库文件`libc.a`或动态链接库文件`libc.so`中。这些链接库一般位于`/lib/`或`/usr/lib/`，或者位于GCC默认搜索的其他链接库目录。

#### 非标准库

如果要链接的是非标准的链接库，则必需显式使用`-l`选项。

```bash
$ gcc -o hello hello.c -lncurses
```

上述命令将链接非标准的`ncurses`库，并且将自动在标准库目录中搜索它的库文件`libncurses.a`。

#### 库搜索路径

有三种方式可以链接在GCC默认搜索路径以外的链接库。

方式一是把链接库作为普通的目标文件：

```bash
$ gcc -o hello hello.c /usr/local/lib/libncurses.a
```

> 采用这种方式，不需要使用`-l`选项指定链接库。

方式二是使用`-L`选项来为GCC增加一个搜索链接库的目录：

```bash
$ gcc -o hello -L/usr/local/lib/ -lncurses hello.c
```

在同一命令中，`-L`选项可以有多个，或者在一个`-L`选项内使用冒号分割的路径列表。

方式三是把所需链接库的目录加到环境变量`LIBRARYPATH`中，目录列表使用逗号分隔。环境变量`LIBRARYPATH`添加的搜索路径的优先级小于`-L`添加的搜索路径。

> 环境变量`LD_LIBRARY_PATH` （OS X中是`DYLD_LIBRARY_PATH`）提供了共享链接库文件的搜索位置，搜索目录之间使用逗号分隔。注意，该环境变量不是由GCC所读取，而是由可执行文件读取，并动态链接到共享链接库。

不在通常位置的链接库，可以通过`find 基路径 -name 'foo*'`来查找。通常，链接库如果放在`/some/path/lib`中，则对应的头文件一定在`/some/path/include`中。

在硬盘中到处找库文件是一件很恼人的事情，可以使用`pkg-config`，它维护了一个包含配置信息和位置信息的数据库，然后`pkg-config`会报告编译时需要的这些信息。

```bash
$ pkg-config --libs gsl libxml-2.0
-lgsl -lgslcblas -lm -lxml2   (不仅能获取链接库名，而且会输出它们的依赖顺序。并且如果这些库没在位置，还会使用“-L”选项指出它的位置)
$ pkg-config --cflags gsl libxml-2.0
-I/usr/include/libxml2   （获取头文件的位置）
```

在shell的命令行中，当把一条命令用单引号包围时，这条命令会被其自身的输出替代。例如，输入：

```bash
$ gcc 'pkg-config --cflags --libs gsl libxml-2.0' -o specific specific.c
```

编译器看到的是：

```bash
$ gcc -I/usr/include/libxml2 -lgsl -lgslcblas -lm -lxml2 -o specific specific.c
```

#### 给链接器传递参数

通过使用`-Wl`选项（可以有多个）后接一个逗号分隔的列表（中间不能有空格），可以直接将选项传递给链接器，例如：

```bash
$ gcc -lncurses -v -Wl,-Map,hello.map hello.c
```

上述命令指示链接器输出一个链接脚本和一个内在映射。

#### 运行时链接

上面指定库搜索路径的方式都是为链接器服务的，而如果要为可执行程序在运行时提供共享链接库的搜索路径，则有两种方法：

方法一、在环境变量`LD_LIBRARY_PATH`（Linux、Cygwin）或`DYLD_LIBRARY_PATH`（OS X）中定义运行时链接的库搜索路径。

方法二、通过`-Wl,R`选项将库搜索路径显式标注到可执行文件中：

```makefile
LDADD = -Llibpath -Wl,Rlibpath
```

#### 独立程序

链接器除了链接链接库外，还需要链接操作系统专用的启动码（startup code），程序需要启动码才能被加载，并与操作系统进行顺利交互。

启动码位于标准目标文件`crt0.o` 中，其中包含了可执行文件实际的入口点。

另外，在大多数系统中，GCC也会自动链接目标文件`crtbegin.o`和`crtend.o`中的初始化与清理子程序。

然而，如果正在编写一个独立程序，例如操作系统或在嵌入式微控制器上执行的应用，可以使用`-ffreestanding`和`-nostartfiles`选项，指示GCC不要链接启动码。

使用`-nostdlib`选项可以禁止自动链接到C标准链接库。如果使用该选项，则必须为程序中所用到的标准函数提供自己的版本。

最后，在独立环境中，C程序不需要从`main()`开始。可以在GCC命令行中使用**链接器选项**`-ename`，为程序指定其他的入口点。

### 优化

#### 优化等级

优化等级代表多个优化技术的集合，使用`-O`选项设定。

- `-O0`：关闭所有的优化选项。
- `-O`、`-O1`：不会增加过多的编译时间的优化。
- `-O2`：应用几乎所有支持的优化技术。使用该选项通常情况下会增加编译时间。
- `-O3`：包括了`-O2`所有的优化技术，同时生成inline函数。
- `-Os`：类似`-O2`，但没有包括任何可能导致代码大小增加的优化技术。该选项使得最终的程序文件大小显著地减小，常常被用于生成最终版本。

#### 优化技术

GCC可以使用`-f`选项指示需要采用的优化技术，从而允许对优化进行更为细致的控制。

```bash
$ gcc -Wall -O3 -fno-inline-functions -o hello hello.c -lncurses
```

上述命令启用`-O3`的所有优化技术，但是禁用其中的函数inline编译。

#### 适用于特定架构的选项

这些适用于特定架构的选项都以`-m`开头。

## 调试模式

C语言的调试器可以使用GDB或LLDB，这里使用GDB。

为了使用gdb调试程序，必需先使用GCC的`-g`选项编译和链接程序，这样才会在生成的可执行程序中包含符号表。例如：

```bash
$ gcc hello.c -o hello -g -Wall
```

然后，以要调试的可执行程序为参数启动gdb：

```bash
$ gdb ./hello
```

执行完上述命令后，将进入gdb的交互模式。可以在提示符`(gdb)`后输入调试命令进行调试。

`list`或`l`（实际上`li`、`lis`也是可以的，只要不会造成歧义。下同）调试命令会列出被调试程度的起始几行源代码（默认显示10行，可以使用`set listsize 行数`自定义）。如果连续使用`list`命令，则会不断显示接下来的若干行源代码。

- `list 行号`表示从当前文件的指定行开始显示若干行代码（默认显示10行）。
- `list 文件名:行号`表示从指定文件的指定行开始显示若干行代码（默认显示10行）。
- `list 函数名`表示从指定函数定义处开始显示若干行代码（默认显示10行）。
- `list 起始行 结束行`表示显示指定范围内的源代码。

`break`调试命令用于设置断点。例如，`b 15`表示在当前文件的第15行设置断点。`b hello.c:15`表示在`hello.c`文件的第15行设置断点。`b main`在main函数的第一行代码处设定断点。

可以使用两种方式为断点设置生效条件：

- 带条件的`break`命令：`break 28 if i == limit - 1`。
- 带条件的`condition`命令：`condition 2 *p1 != *p2`。要删除中断条件，只要使用不带中断条件的`condition`命令。例如，`condition 2`。

`tbreak`调试命令用于设置临时断点。GDB到时这个断点后就自动删除它，即只中断一次的断点。用法同`break`。

`delete` 或`d`调试命令用于删除断点。`d 2`表示删除编号为2的断点。`d 1-3`表示删除编号从1到3的断点。`d`表示删除所有断点。

`disable`调试命令用于禁用断点。`disable 2`表示禁用编号为2的断点。`disable 1-3`表示禁用编号从1到3的断点。`disable`表示禁用所有断点。

`ignore`调试命令用于忽略断点而不中断程序的执行。`ignore 2 5`表示忽略编号为2的断点5次。

`info break`表示列出所有断点。

`watch 表达式` ：当`表达式`的值改变时，调试器中断程序执行。与`break`设置的断点是针对代码行不同，`watch`设置的观测点（watchpoint）是针对表达式。

`rwatch 表达式`：每当程序读取跟计算`表达式`相关的任何对象时，调试器中断程序执行。

`awatch 表达式`：每当程序读取或修改跟计算`表达式`相关的任何对象时，调试器中断程序执行。

`run`调试命令开始执行程序直到遇到断点或程序结尾。

`next`调试命令不带参数时，继续执行下一行代码，然后再次中断。`next 5`表示继续执行接下来的5行代码，然后中断。如果在执行完这5行之前碰到断点，则程序将在该断点处中断。

`step`或`s`调试命令不带参数时，如果当前行有函数调用，则跳进函数内，并在函数内的第一行代码处停下来。如果当前行没有函数调用，则同`step`命令。`step 5`表示在跳进函数内继续执行5行代码后中断或继续执行5行代码后中断。如果在执行完这5行之前碰到断点，则程序将在该断点处中断。

`finish`调试命令表示继续执行到当前的函数结束，并在程序流将控制权交回到该函数的调用者时中断。

`print`调试命令显示当前上下文中给定表达式的值。例如：

```
(gdb) p *a
$1 = 65
(gdb) p/t （“/t”表示输出二进制表示法。p与格式选项之间不能有空格。p不带参数时表示输出上一条命令的值）
$2 = 1000001
(gdb) p/c  (“/c”表示输出字符和它的十进制编码)
$3 = 65 'A'
```

GDB以`$编号=值`方式输出结果，其中`$编号`是一个GDB变量，可以在后续引用它。

如果`arr`是一个数组，则`p *arr`显示数组第一个元素，`p *arr@10`显示从地址`arr`开始的10个数据。

`x`命令可以显示指定内存区域的值：

```
(gdb) x/s msg   （以字符串形式显示从msg指针开始到空字符结束的内存区域值）
0x402000 <msg>: "Hello world!\n"
(gdb) x/15xb   （以十六进制形式显示从msg指针开始的15个字节内容）
0x402000 <msg>: 0x48 0x65 0x6c 0x6c 0x6f 0x20 0x77 0x6f
0x402008 <msg+8>:    0x72 0x6c 0x64 0x21 0x0a 0x00 0x00
```

`continue`或`c`调试命令让程序可以继续执行，直到遇到下一个断点或程序的尾部。`continue 5`表示继续执行程序，并且当前断言将被忽略5次。

在`(gdb)`提示符后直接回车，则GDB会重复执行上一个命令，只要该动作是合理的。例如，GDB会自动重复执行`step`和`next`命令，但是不会自动重复执行`run`命令。

`backtrace`或`bt`可获知程序流执行到此位置时函数调用的次序（即调用轨迹）。另外，`where`和`info stack`作用与`bt`类似。

`frame`或`info frame`查看当前栈帧（frame）信息，`f 1`查看编号为1的栈帧信息。栈帧编号从0开始（当前栈帧）。

`info locals`列出当前栈帧处的函数的局部变量及它们的当前值。

`info args`列出当前栈帧处的函数的参数及它们的当前值。

`quit`调试命令退出GDB。

`kill`调试命令终止调试程序，但不会退出GDB，所有被调试程序的设置，包括被调试程序的命令行参数都会被保留下来。当再次使用`run`命令执行程序时，GDB如果发现可执行文件已经被修改过，会重新加载它。

`info`调试命令显示被调试程序的状态信息。

`show`调试命令显示调试器的状态信息。

`help`调试命令会显示调试命令类别列表。要显示某一类别下的命令，可在`help`后跟上类别名称，例如：`help aliases`。如果要显示某个命令用法，则可在`help`后跟上该命令名称，例如：`h run`。

可以使用`Tab`键进行自动补全。

如果一开始启动GDB时，没有指定被调试的程序。则可以使用`file`调试命令来指定被调试程序。

如果希望在启动GDB时，不显示启动信息，则可使用`-silent`或`-quiet`选项（GDB命令行选项前可以使用一个或二个连字号）。例如：`gdb -silent`。

有三种方式可以为被调试程序传递参数：

- 使用GDB的`--args`选项：`--args`选项后面必须紧接着被调试程序，然后是被调试程序的命令行参数。例如，

  ```bash
  $ gdb --args myprog -d "$HOME"
  ```

- 使用`set args`调试命令。例如，

  ```
  (gdb) set args -d "$HOME"
  ```

  `set args`后不跟参数时，表示消除所有被调试程序的命令行参数。

  `show args`调试命令显示当前传递给被调试程序的命令行参数。

- 使用`run`调试命令后跟被调试程序的命令行参数。例如，

  ```
  (gdb) run -d "$HOME"
  ```

# 程序结构

C程序主要由函数组成，函数定义不能嵌套，但函数可以调用其他函数，函数包含循序执行语句。

C程序的顶层结构包含：

- 注释
- 预处理指令
- 全局声明
- 函数原型和定义

## 第一个程序

hello.c：

```c
#include <stdio.h>

int main(void) {
    printf("Hello world!");
    return 0;
}
```

## 源文件

C程序的源代码保存在**源文件**中，扩展名通常是`.c`。

另外，可将多个源文件共享的声明和定义保存到一个单独的头文件（header file）中，头文件习惯上使用扩展名`.h`。然后，在每个需要的源文件中利用`#include`指令来引用该头文件。 

> 每个源文件，如果不是完全为空， 则必须以一个换行符作为结尾。

## 编码

C代码是区分大小写的。

编译器转换代码时所处的环境称为翻译环境（translation environment），程序执行时所处的环境称为运行环境（execution environment）。C语言定义了两个字符集：源代码字符集和运行字符集。源代码字符集是用于组成C代码的字符集，而运行字符集是可以被执行程序解释的字符集。在许多C语言的实现中，这两个字符集是一样的。

这两种字符集都包含基本字符集（basic character set）和扩展字符（extended character）。C语言没有规定扩展字符，这通常由本地语言决定。扩展字符加上基本字符集，组成扩展字符集（extended character set）。

基本字符集包括：

- 拉丁字母（大小写共52个字符）
- 十进制阿拉伯数字（10个）
- 29个符号：`!"#%&'()*+,-./:;<=>?[\]^_{|}~`
- 5种空白符：空格、水平制表符、垂直制表符、换行符、换页符
- 4个不可打印字符：NULL字符、警报（alert）、退格（backspace）、回车（carriage return）

原本C语言主要使用7位的ASCII码。现在，也可以采用两种表示大型字符集的标准化方法：

- 宽字符（wide character）：每个字符使用相同的位长。虽然C标准没规定宽字符必须使用Unicode字符集，但许多实现使用UTF-16和UTF-32来处理宽字符。
- 多字节字符（multibyte character）：每个字符可以采用一个或多个字节表示。某些多字节字符的编码机制是带状态的，对给定多字节序列的翻译会受到控制字符位置的影响。这种控制字符称为移位序列（shift sequence）。UTF-8不需要使用移位序列。

多字节字符串比宽字符串更难处理。但多字节字符编码独立于系统架构，而宽字符编码是依赖于所给定系统的字节顺序的（即大端和小端字节顺序问题）。

### 转义序列

#### 通用字符名

通用字符名（universal character name）即字符的Unicode值，与实现的编码格式无关。其格式如下：

```c
\uxxxx   //一个x表示一个十六进制数字
\Uxxxxxxxx
```

> `\uxxxx`等价于`\U0000xxxx`。

通用字符名可以用于标识符、字符常量、字符串字面量，但是不得用于表示*基本字符集*内的字符。

当采用通用字符名指定一个字符时，编译器会将其存储（转换）为当前实现版本所使用的字符集对应的编码。

#### 特殊字符转义序列

| 转义序列 | 字符值     |
| -------- | ---------- |
| `\'`     | 一个单引号 |
| `\"`     | 一个双引号 |
| `\?`     | 一个问号   |
| `\\`     | 一个反斜线 |
| `\a`     | 警告       |
| `\b`     | 退格       |
| `\f`     | 换页       |
| `\n`     | 换行       |
| `\r`     | 回车       |
| `\t`     | 水平制表符 |
| `\v`     | 垂直制表符 |

特殊字符转义序列只能出现在字符字面量或字符串字面量中。

#### 八进制和十六进制转义序列

八进制和十六进制转义序列可以表示`unsigned char`类型的取值范围内的任何字符，或者`wchar_t`类型取值范围内的任何宽字符。

```c
\o、\oo、\ooo  //八进制转义序列。一个o表示一个八进制数字
\x…  //十六进制转义序列。一个x表示一个十六进制数字
```

八进制和十六进制转义序列用法与通用字符名相同。

#### 双字符组

| 双字符组 | 等效字符 |
| -------- | -------- |
| `<:`     | `[`      |
| `:>`     | `]`      |
| `<%`     | `{`      |
| `%>`     | `}`      |
| `%:`     | `#`      |
| `%:%:`   | `##`     |

上述字符出现在字符字面量或字符串字面量中，则不会被解释成双字符组。在其他位置时，才被解释为双字符组。例如：

```c
int arr<::> = <% 10, 20, 30 %>;  //等价于：int arr[] = {10, 20, 30};
```

#### 三字符组

| 三字符组 | 等效字符 |
| -------- | -------- |
| `??(`    | `[`      |
| `??)`    | `]`      |
| `??<`    | `{`      |
| `??>`    | `}`      |
| `??=`    | `#`      |
| `??/`    | `\`      |
| `??!`    | `|`      |
| `??'`    | `^`      |
| `??-`    | `~`      |

三字符组不同于双字符组，它是在预处理阶段被替换成等效字符。并且，它在任何位置都会被解释为三字符组，包括在字符字面量和字符串字面量中。

#### 其他

无论何时，只要反斜线符后面紧跟着换行符，预处理器就会将两者（反斜线符和换行符）都删除。

## 保留字

![C语言保留字](C/C语言保留字.png)

## 标识符

C语言有四种标识符的命名空间：

- 标签名（label）
- 标识（tag）：用来标识结构、联合与枚举类型
- 结构或联合中的成员名称
- 普通标识符

## 注释

```c
// 单行注释以//开始直到行尾。（仅适用于C99或更新的版本。）

/* 这是块注释，它可以适用于C89。
   块注释可以跨越多行。
   块注释不能再嵌套块注释，但可以嵌套单//行注释。
*/
```

在字符或字符串字面量中的`/*`、`*/`或`//`，不会被视为注释。

如果想要注释掉包含块注释的部分代码，可以使用条件预处理指令：

```c
#if 0
  const double pi = 3.1415926;  /* pi是一个常量 */
  area = pi * r * r;  /* 计算面积 */
#endif
```

预处理器会把每个注释都替换成一个空格。因此，`min/*max*/Value`将变成两个标记：“min Value”。

## 程序入口

每个C程序都必须定义至少一个`main`函数，它是程序开始执行时第一个被调用的函数，是程序结构中最顶层的函数，其他函数会以子例程的方式被它调用。

`main`函数有如下形式：

```c
// 无参形式
int main(void) {…}
int main() {…}

// 带参形式。
// 参数argc表示在命令行中执行main()函数的参数个数，包含程序名在内，argc的值至少是1；
// 参数argv是这些参数名组成的数组。
int main(int argc, char *argv[]) {
  printf("Program name: %s\n", argv[0]); // argv[0]保存着程序名。
  for (int i=1; i<argc; ++i)
     printf("Argument %d: %s\n", i, argv[i]);
  return 0;
}
```

## 编程规范

C语言采用自由的代码格式，没有换行或缩排规则。除了预处理指令的格式化自由度会低一些：一条指令必须独占一行，并且`#`符号前面除了空格与制表符之外，不能有别的字符。

一些通用的编程规范：（非强制）

- 每个新的声明和语句都新起一行；
- 使用缩进以反映语句块的嵌套结构。

# 基本类型

## 数值类型

### 整数类型

有符号整型：

| 类型             | 同义词                                                |
| ---------------- | ----------------------------------------------------- |
| int              | signed、signed int                                    |
| short            | short int、signed short、signed short int             |
| long             | long int、signed long、signed long int                |
| long long（C99） | long long int、signed long long、signed long long int |

无符号整型：

| 类型                      | 同义词                 |
| ------------------------- | ---------------------- |
| unsigned int              | unsigned               |
| unsigned short            | unsigned short int     |
| unsigned long             | unsigned long int      |
| unsigned long long（C99） | unsigned long long int |

整型的存储空间大小和取值范围：

| 类型               | 存储空间大小 | 最小值               | 最大值               |
| ------------------ | ------------ | -------------------- | -------------------- |
| char               | 1个字节      | -128或0              | 127或255             |
| signed char        | 1个字节      | -128                 | 127                  |
| unsigned char      | 1个字节      | 0                    | 255                  |
| int                | 2个或4个字节 | -32768或-2147483648  | 32767或2147483647    |
| unsigned int       | 2个或4个字节 | 0                    | 65535或4294967295    |
| short              | 2个字节      | -32768               | 32767                |
| unsigned short     | 2个字节      | 0                    | 65535                |
| long               | 4个字节      | -2147483648          | 2147483647           |
| unsigned long      | 4个字节      | 0                    | 4294967295           |
| long long          | 8个字节      | -9223372036854775808 | 9223372036854775807  |
| unsigned long long | 8个字节      | 0                    | 18446744073709551615 |

> 可以在`limits.h`头文件中找到所采用编译器中整数类型的取值范围，它们定义为宏，例如宏`INT_MIN`、`INT_MAX`和`UINT_MAX`等。

在整数的算术运算中，可能会发生溢出（overflow）情况。C语言仅对无符号整数类型指明了溢出的处理结果，对其他类型则没有定义。无符号整数运算的有效结果，等于除以`UTYPE_MAX + 1`之后的余数。其中`UTYPE_MAX`是该无符号类型所能表示的最大值。

#### 确定位长的整数类型

在C99中，头文件stdint.h中定义了确定位长的整数类型。

| 类型                        | 含义                              | 实现版本              |
| --------------------------- | --------------------------------- | --------------------- |
| intN_t、uintN_t             | 位长为N的整数类型                 | 可选                  |
| int_leastN_t、uint_leastN_t | 位长至少为N的整数类型             | 要求N = 8、16、32、64 |
| int_fastN_t、uint_fastN_t   | 处理位长至少为N的最快速的整数类型 | 要求N = 8、16、32、64 |
| intmax_t、uintmax_t         | 位长最大的整数类型                | 需要                  |
| intptr_t、uintptr_t         | 位长足以存储指针值的整数类型      | 可选                  |

带符号的确定位长整数类型有个特点：必须使用2的补码的二进制表示方式。因此，它们的最小值是-2^N-1^，最大值是2^N-1^-1。

#### 整数字面量

十进制整数字面量：起始数字不可为0。例如：255。

八进制整数字面量：以0开始的数字。例如：047。

十六进制整数字面量：以0x或0X作为前缀的数字。例如：0xFF、0Xff。

整数字面量通常会认定为`int`类型，除非这个字面量值在`int`所能表示的范围之外。在这种情况下，编译器会按照类型层次自动选择第一个范围足够表示该值的类型。

- 对于十进制字面量来说，类型层次为：`int`、`long`、`long long`。
- 对于八进制和十六进制字面量来说，类型层次为：`int`、`unsigned int`、`long`、`unsigned long`、`long long`、`unsigned long long`。

也可以利用后缀来显式地定义字面量的类型。如果字面量具有后缀`l`或`L`，其类型就是`long`（在必要情况下，还可以为一个范围更大的类型。这个“更大”对应于前面提到的类型层次）。类似地，如果后缀是`ll` 或`LL`，则类型至少为`long long`。后缀为`u` 或`U`则为无符号类型。`long`后缀与无符号后缀可以混合使用：

```c
512U     //unsigned int
0Xf0fUL  //unsigned long
0777LL   //long long
0xAAAllu //unsigned long long
```

### 浮点类型

| 类型         | 存储大小 | 取值范围  | 最小正数值 | 精度 |
| ------------ | -------- | --------- | ---------- | ---- |
| float        | 4位      | ±3.4E38   | 1.2E-38    | 6位  |
| double       | 8位      | ±1.7E308  | 2.3E-308   | 15位 |
| long  double | 10位     | ±1.1E4932 | 3.4E-4932  | 19位 |

C语言中，对浮点数进行算术运算时，通常需要采用`double`或者更高精度的类型。实现版本所采用的浮点精度由头文件float.h中定义的宏`FLT_EVAL_METHOD`指定。例如，如果宏`FLT_EVAL_METHOD`值为1,则下面的乘法运算采用`double`类型：

```c
float height = 1.2345, width = 2.3456;
double area = height * width;
```

#### 浮点字面量

十进制浮点字面量：10.0、10.、.234、67e-12（“e”或“E”是以10为底数）。

十六进制浮点字面量（C99）：0xa.fP0、0X5.78p9（“p”或“P”是以2为底数）。

十六进制浮点字面量的一个优点是，它可以被精准地存储在计算机的二进制浮点格式中，没有取近似值的误差。

十六进制浮点字面量必须包括指数部分，即便其指数值为0。这么做是为了区分类型后缀F（在指数之后）与十六进制数字F（在指数之前）。

浮点字面量默认是`double`类型，可以用后缀`f`或`F`来注明该字面量是`float`类型，或者用后缀`l`或`L`来注明此字面量是`long double`类型。

### 复数浮点类型

C99支持复数浮点类型，并扩充了数学库以包括复数算术函数，它们声明在头文件complex.h中。

C11标准中，对复数的支持是可选的。如果定义了宏`__STDC_NO_COMPLEX__`，则所采用的实现版本不支持复数，即不包含头文件complex.h。

在C语言中，复数被表示成一对浮点数，这对浮点数分别是实部和虚部。两者的数据类型是一样的，可以是`float`、`double`或`long double`。相应地，有三种复数浮点类型：

- `float _Complex`
- `double _Complex`
- `long double _Complex`

另外，实现版本中可能还包括三种表示纯虚数的类型：

- `float imaginary`
- `double imaginary`
- `long double imaginary`

头文件complex.h定义了宏`complex`和`I`。宏`complex`是关键字`_Complex`的同义词。宏`I`代表虚数单位i，且其类型是`const float _Complex`。

C11中提供了宏`CMPLX`、`CMPLXF`和`CMPLXL`，分别用于构造`double _Complex`、`float _Complex`和`long double _Complex`复数。例如：`CMPLX(1.0, 2.0)`。

## 字符类型

C语言中的字符类型实际上都是整数类型，可以对它们做算术运算。由程序自身决定是否将字符类型变量的值解释为字符码或其他东西。

### 单字节字符

`char`类型表示单字节字符。它可以是`signed char`的同义词，也可以是`unsigned char`的同义词，这由所采用的编译器实现版本决定。严格地说，`char`、`signed char`和`unsigned char`是三种不同的数据类型，需要进行转换才能把一种类型映射到另一种类型。

如果程序会用到的字符值包括小于0或大于127的情况，则应该使用`signed char`和`unsigned char`，而不是`char`。

单字节字符字面量使用单引号包围：`'a'`、`'9'`、`'\0'`、`'\33'`、`'\033'`、`'\x1B'`、`'\t'`。

源代码字符集中的所有字符，均可表示为字符字面量，除了单引号、反斜线和换行符。为了表示这些字符，必须使用转义字符：`'\''`、`'\\'`、`'\n'`。

>  注意：单字节字符字面量默认的类型是`int`。

可以使用字符字面量或整数值初始化`char`类型变量：

```c
char tab = '\t';
char character = 74;
```

`char`类型变量有双重性：可以把它解释为一个字符，也可以解释为一个整数。因此，可以对`char`类型的值进行算术运算，同时仍把它当做一个字符：

```c
char letter = 'C';
letter = letter + 3;
```

### 宽字符

C语言用`wchar_t`类型（stddef.h）表示宽字符。当宽字符采用Unicode标准时（即定义了宏`__STDC_ISO_10646__`），`wchar_t`类型至少是16位或32位长，`wchar_t`类型的一个值代表一个Unicode字符。

> 在Windows中，`wchar_t`有2个字节，存储UTF-16编码的字符。

由于`wchar_t`的大小是由实现代码定义，当代码需要在不同的系统之间移植时，这种不确定性和可变性降低了其可用性。因此，C11引入额外的宽字符类型`char16_t`和`char32_t`（uchar.h）。它们被定义为无符号整数类型，在定义了宏`_STDC_UTF_16__`的C实现中，类型`char16_t`的字符采用UTF-16编码；在定义了宏`_STDC_UTF_32__`的C实现中，类型`char32_t`的字符采用UTF-32编码。

`wchar_t`字符字面量必须有一个`L`前缀，`char16_t`字符字面量必须有一个`u`前缀，`char32_t`字符字面量必须有一个`U`前缀：

```c
// wchar_t
L'A'、L'\xF82'、L'\u0100'
// char16_t
u'A'、u'\x10f'、u'\u0100'
// char32_t
U'A'、U'\x222B'、U'\u27FA'
```

### 多字节字符

C语言中没有专门的多字节字符类型，而是使用`char`数组或`char`指针来存储多字节字符。因此，也没有专门的多字节字符字面量。

C语言提供了一些标准函数，来在宽字符与多字节字符之间转换。

`wctomb()`用于将宽字符转换为多字节字符：

```c
wchar_t wc = L'\x3B1';    // Greek lowercase alpha
char mbStr[10] = "";
int nBytes = 0;  // 多字节字符所需要的字节数量
nBytes = wctomb(mbStr, wc);  // mbStr = "\xCE\xB1"
if(nBytes < 0)
  puts("Not a valid multibyte character in your locale.");
```

相应地，`mbtowc()`将一个多字节字符转换为宽字符。

## 布尔类型

C99引入了无符号整数类型`_Bool`用来表示布尔类型。布尔值真被定义为`1`，假被定义为`0`。

如果程序中包含`stdbool.h`头文件，则可以使用标识符`bool`、`true`和`false`。宏`bool`是`_Bool`类型的同义词，符号常量`true`值为`1`，`false`值为`0`。

## 空类型

C语言中空类型使用`void`表示。

 不可以用`void`声明变量或常量。

### void用于函数声明

声明没有返回值的函数：

```c
void perror(const char *);
```

声明不带参数的函数：

```c
FILE *tmpfile(void);
```

### void类型表达式

void类型表达式指的是没有值的表达式。例如，调用一个没有返回值的函数，就是一种void类型表达式：

```c
char filename[] = "memo.txt";
if (fopen(filename, "r") == NULL)
  perror(filename);  //void表达式
```

使用`(void)`对一个表达式进行强制类型转换，将显式地丢弃该表达式的值：

```c
(void)printf("I don't need this function's return value!\n");
```

### 指向void的指针

一个`void *`类型的指针代表了对象的地址，但没有该对象的类型信息。这种“无数据类型”指针主要用于声明函数，让函数可使用各种类型的指针参数，或者返回一个“多用途”的指针。

```c
void *realloc(void *ptr, size_t size);
```

可将一个void指针值赋值给另一个对象指针类型，反之亦然，这都不需要进行显式的类型转换。

# 声明

## 变量声明

## 常量声明

### `#define`

### `const`

## 命名规范

# 数组

# 字符串

`char`字符串使用双引号包围，`wchar_t`字符串字面量需要在左引号前加上`L`前缀，`char16_t`字符串字面量必须有一个`u`前缀，`char32_t`字符串字面量必须有一个`U`前缀，使用UTF-8编码的多字节字符串字面量必须有一个`u8`前缀：

```c
char *pStr = "Hello, world!";
wchar_t proverb[] = L"A nod is as good as a wink to a blind horse.";
char16_t *str16 = u"This is a Unicode string using UTF-16 encoding.";
char32_t *str32 = U"This is a Unicode string using UTF-32 encoding.";
char *str8 = u8"This is a Unicode string using UTF-8 encoding.";
```

源代码字符集中的所有字符（包括多字节字符），均可表示为字符串字面量，除了单引号、反斜线和换行符。为了表示这些字符，必须使用转义字符：`'\''`、`'\\'`、`'\n'`。无法用单字节表示的字符，会以多字节字符方式存储。

字符串字面量是一个静态的字符数组，它内部包含字符码，最后跟着一个字符串终止符，也就是空字符（`\0`）。空字符串`""`在内存中占用一个字节，该字节存储了用来表示字符串终止的空字符。

可以使用字符串字面量来初始化一个`char`数组，也可以初始化一个指向`char`的指针：

```c
char doc_path[128] = ".\\share\\doc";  //".\share\doc"
char *pStr = "Hello, world!";
```

字符串字面量与数组名称的功能一样，它代表了其第一个元素的地址。

字符串字面量中的字符采用实现默认的字符编码。C11提供了一个UTF-8字符串字面量，它以`u8`为前缀，字符采用UTF-8编码。当实现版本默认编码为UTF-8时，以`u8`前缀的字符串字面量与不带前缀的字符串字面量是一样的。

类似地，可以通过使用`L`、`u`和`U`前缀，来定义`wchar_t`、`char16_t`和`char32_t`宽字符串字面量。宽字符串字面量是以一个以0字符结尾的宽字符数组。

编译器通过调用`mbstowcs()`、`mbrtoc16()`和`mbrtoc32()`函数，会将宽字符串字面量中的多字节字符隐式地转换为相应类型的宽字符。

如果字符串字面量中的多字节字符或者转义序列无法在扩展字符集中表示，该字符串字面量的值将是未定义的。换句话说，其值将取决于所使用的编译器。

编译器的预处理器会将紧邻的字符串字面量（这指是的仅仅通过空格隔开的两个字符串）串联成一个字符串。这种串联方式同样有助于将一个很长的字符串分割成多行以方便阅读。

```c
#define PRG_NAME "EasyLine"
char msg[] = "The installation of " PRG_NAME
             "is now complete.";
```

如果任何紧邻的字符串字面量有前缀，那么串联获得的字符串字面量也具有该前缀。具有不同前缀的字符串字面量是否可以被串联，取决于编译器。

分割字符串字面量为多行的另一种方法，就是利用每行结尾部分的反斜线：

```c
char info[] = 
"This is a string literal broken up into\
  several source code lines.\nNow one more line:\n\
that's enough, the string ends here.";
```

“serveral”之前的空格属于字符串字面量的一部分。而且，两个显式写成`\n`的换行符也属于字符串字面量一部分。

虽然C语言没有严格地禁止修改字符串字面量，但不应该试图这么做。

```c
char *p = "house";
*p = 'm';
```

这个语句不具有可移植性，在某些系统下，将会产生运行错误。一个原因是，编译器将字符串字面量视为常量，可能会将其存储在只读存储器中，这种情况下，试图对此字符串执行写入操作将会产生错误。另一个原因是，如果程序中有两个或更多完全相同的字符串字面量，编译器可能会将它们存储在相同的位置，因此，修改一个字符串会对其他字符串造成不可预计的影响。

然而，如果使用一个字符串常量来初始化一个数组变量，则可以修改数组内容：

```c
char s[] = "house";
s[0] = 'm';
```

# 枚举类型

基本类型和枚举类型统称算术类型（arithmetic type）。

枚举类型是一种由用户在程序中定义的整数类型。

```c
enum color {black, red, green, yellow, blue, white=7, gray};
enum color bgColor = blue, fgColor = yellow;
void setFgColor(enum color fgc);
```

枚举常量的数据类型是`int`。

对于给定枚举类型中的每个枚举常量都表示一个特定值，该值可以是隐式地由枚举值的位置所决定，也可以是显式地使用一个常量表达式来初始化。如果没有初始化，第一个枚举常量的值为0，其后面常量的值为前面枚举量值加1。因此，上面例子中的枚举常量的值依次为：0、1、2、3、4、7、8。

由于枚举类型总是对应一种标准整数类型。因此，C程序可以使用枚举类型的变量进行一般算术运算。

一个枚举中的不同枚举常量，可以具有相同的值。

```c
enum {OFF, ON, STOP=0, GO=1, CLOSED=0, OPEN=1};
```

枚举类型定义时，如果只想定义常量，而不想声明属于该枚举类型的变量， 则可以省略类型名。用这种方式定义整数常量，比使用一长串的`#define`命令更好，因为枚举同时提供编译器常量的名称及其数值，这会带来额外的好处，例如，在调试器中可以显示常量名称。

# 表达式

## 算术表达式

## 关系表达式

## 逻辑表达式

## 赋值表达式

### 交换值

## 位运算表达式

## 条件表达式

# 语句

## 语句结束符

## 表达式语句

## 块语句

## 空语句

## 选择语句

### 条件语句

### 多分支语句

## 循环语句

### while循环

### do-while循环

### for循环

## 跳转语句

# 子程序

## 函数

### 函数定义

函数定义不能嵌套在另一个函数的定义之中。

### 函数声明

### `__func__`

预定义标识符`__func__`，可以在任何函数中使用它来获取该函数的名称（字符串）。

```c
#include <stdio.h>
int test_func(char *s) {
  if (s==NULL) {
    fprintf(stderr, "%s: received null pointer argument\n", __func__);
    return -1;
  }
}
```



## 运算符

### 优先级

### 结合性

## 函数类型

# 指针

算术类型和指针类型统称标量类型（scalar type）。

# 结构

数组和结构统称聚合类型（aggregate type）。指针和聚合类型也称为派生类型。

# 联合

## 位字段

# 集合类型

## 列表

## 映射/字典

## 集

# 作用域和可见性

## 作用域

C语言有四种作用域：

- 文件作用域：如果声明标识符的地方位于所有语句块和参数列表之外，则该标识符就具有文件作用域。文件作用域的标识符在声明后直到翻译单元结束的任何地方可以访问。
- 块作用域：除标签之外，在语句块内声明的标识符具有块作用域。这样的标识符只能在从其声明处到包含该声明的最小语句块结尾处的范围内可以访问。在一个函数定义头部的参数名称，也具有块作用域，其在整个函数体内都有效。
  块作用域可以嵌套。
- 函数原型作用域：函数原型中参数名具有函数原型作用域。这些参数名在原型外没有意义，通常只用注释。
- 函数作用域：一个标签的作用域一定是该标签所在的整个函数体内，即使它被放在嵌套语句块内。例如，可以使用`goto`语句，在同一个函数体内，从任意点跳到某个标签处。

标识符的作用域通常从声明之后开始，但是结构、联合、枚举的类型名称，以及枚举常量的名称是个例外：当它们出现在声明中时，它们的作用域就立刻开始，因此它们可以在声明中被本身再次引用。

### 标识符屏蔽

内层块作用域中声明的标识符屏蔽外层块作用域或文件作用域中声明的同名标识符。

函数原型中的参数名屏蔽外层块作用域或文件作用域中声明的同名标识符。

# 内存管理

# 类型系统

## 类型兼容

## 类型转换

### 隐式转换

#### 算术转换

##### 类型转换等级

1. 标准整数类型的等级次序：`_Bool < char < short < int < long < long long`。

2. 带符号整数类型与其对应的无符号整数类型具有相同的等级。
3. 标准整数类型比相同宽度的扩展整数类型等级更高。
4. 枚举类型与其对应的整数类型具有相同的等级。
5. 浮点类型的等级次序：`float < double < long double`。
6. 浮点类型的转换等级总是高于任何整数类型。
7. 复数浮点类型与其实部和虚部的类型等级一样。

##### 算术转换规则

1. 如果两个操作数中的一个是浮点类型，则转换等级较低的操作数就会被转换成为转换等级较高的操作数的类型。然而，实数类型只能转换为实数类型，复数类型只能被转换为复数类型：

   ```c
   #include <complex.h>
   
   short n = -10;
   double x = 0.5, y = 0.0;
   float _Complex f_z = 2.0F + 3.0F * I;
   double _Complex d_z = 0.0;
   
   y = n * x;  //n的值转换为double类型
   d_z = f_z + x;  //只有f_z的值被转换为double _Complex类型，该运算的结果也是double _Complex类型
   f_z = f_z / 3;  //常数3被转换为float类型
   d_z = d_z - f_z;  //f_z的值被转换为double _Complex类型
   ```

2. 如果两个操作数都是整数，则会对该两个操作数进行整数提升。即，转换等级低于`int`的操作数将会自动转换为`int`类型。如果`int`范围难以满足需要，则会转换为`unsigned int`类型。

   ```c
   char c = '?';
   unsigned short var = 100;
   
   if (c < 'A')  //字符常量'A'的类型是int，c的值被隐式提升为int以进行比较
     var = var + 1;  //在加法之前，var值被提升到int或unsigned int类型
   ```

3. 如果在整数提升之后，操作数依然具有不同的类型，则

   - 如果一个操作数是无符号类型T，其转换等级不低于另一个操作数，则另一个操作数就会转换为T类型。

   - 如果一个操作数是带符号类型T，其转换等级高于另一个操作数。只要T类型范围足以表示另一个操作数类型所有可能值，则另一个操作数会被转换为T类型。若T类型 不足以表示另一个操作数类型所有可能值，则两个操作数都会被转换为与T相对应的无符号类型。

     ```c
     int i = -1;
     unsigned int limit = 200U;
     long n = 30L;
     
     if (i < limit)  //i的值（-1）将被转换为unsigned int类型，这样等到的结果是一个很大的正数。在任何一个系统上，这个值都大于limit值。因此，此if条件为false。
       x = limit * n; //如果long的范围覆盖unsigned int，则limit将转换为n的类型（即long）。否则（例如int和long都是32位长），那么limit和n都将被转换为unsigned long类型。
     ```

##### 其他隐式转换

1. 在赋值和初始化过程时，右操作数总是被转换成左操作数的类型。
2. 

### 显式转换

## 类型推断

## sizeof

`sizeof(类型)` 表示获取指定类型的空间大小。

`sizeof 表达式` 或`sizeof(表达式)` 表示获取指定表达式类型的空间大小。

`sizeof`的结果类型是`size_t`（stddef.h），它是作为一个无符号整数类型（如`unsigned long`）定义在头文件`stddef.h`、`stdio.h`以及其他头文件中。

## 对象在内存中的对齐方式

类型指定了该类型中用于存储对象的内存地址形式，这些形式包括：

- 所有地址都可以存储
- 只有偶数地址可以存储
- 只有被4整除的地址可以存储
- ……

一个类型的对齐用该类型中两个对象在内存中相距的字节数量来表示。类型对齐的具体值随C语言实现版本的不同而异，但是它们都是2的正整数指数，如1、2、4、8等。

如果一个类型的对齐比另一个类型具有更大的值，则称该类型的对齐方式比另一个类型的对齐方式更严格。

C11提供了操作符`_Alignof`来获取一个类型的对齐，修饰符`_Alignas`来指定一个对象的对齐。

```c
_Alignof(int)   //返回size_t类型的值4
```

如果一个对齐值小于等于`_Alignof(max_align_t)`，则称为基础对齐。所有基本类型和指针类型有一个基础对齐值。此外，实现版本可能也支持对齐值大于`_Alignof(max_align_t)`，这种情况被称为扩展对齐（extended alignment）。

当一个对象用修饰符`_Alignas`定义时，它可拥有较其类型本身所需的对齐值更为严格的对齐值。`_Alignas`的参数可以是一个整数常量表达式，其值为一个有效的对齐值，或一个类型：

```c
_Alignas(4) short var;  //定义short类型的变量var，其拥有4字节的对齐值
_Alignas(double) float x;  //定义float类型变量x，其拥有double类型的对齐值
```

`_Alignas(type)`等效于`_Alignas(_Alignof(type))`。

头文件stdalign.h中定义了`alignof`和`alignas`作为`_Alignof`和`_Alignas`的同义词。

## typedef

# 别名

## 类型别名

# 输入和输出

# 异常处理

# 断言

# 正则表达式

# 并发编程

# 网络编程

# 国际化和本地化

## 日期和时间

# 元编程

# 预处理指令

预处理指令通常都是独占一行，因为行结束符视为预处理器指令的终止。

## #include

include目录的搜索顺序：

1. 包含指定源文件的目录（只对在`#include`指令中以引号括起来的头文件名进行搜索）。
2. 采用`-iquote 路径1:…:路径N` 选项指定的目录（只对在`#include`指令中以引号括起来的头文件名进行搜索）。
3. 采用`-I 路径1:…:路径N` 选项指定的目录（对所有`#include` 指令中的头文件名进行搜索，无论文件名是在引号中，还是在尖括号中）。
4. 采用环境变量`CPATH`指定的目录。
5. 采用`-isystem 路径1:…:路径N` 选项指定的目录（只对在`#include`指令中以尖括号括起来的头文件名进行搜索）。
6. 采用环境变量`C_INCLUDE_PATH` 指定的目录。
7. 系统默认的include目录。

# 模块

每个C源文件，连同通过`#include`指令引用的头文件，构成一个翻译单元（translation unit）。

编译器将一个C程序的每个翻译单元翻译成一个独立的目标文件（object file）。目标文件的扩展名通常为`.o`或`.obj`。然后，编译器调用链接器（linker）将所有的目标文件和所用到的链接库函数结合起来，成为一个可执行文件（executable file）。

目标文件也称为模块（module）。一个链接库包含了多个编译好的可以快速获取的模块，模块里有许多标准函数。

# 构建管理

make工具可以自动管理具有任意大小与复杂程序的程序的编译过程，而且，它会比较相关文件的更新时间，以避免重复之前的工作。更重要的是，使用make命令可以管理定义如何构建各种目标的规则，并且自动分析所涉及文件之间的依赖关系 。

## Makefile文件

make在执行构建时，需要一个构建文件来告诉make如何去构建程序。这个构建文件默认是`makefile`（GNU make还可以是`Makefile`） 文件，也可以使用`-f`选项来显式指定一个构建文件。

> 实际上，makefile文件不是必须的。在执行`make`时，如果没有找到makefile文件，则使用make的内置规则（即`make -p`输出的内容）。

MyMakefile：

```makefile
# A basic makefile

CC = gcc
CFLAGS = -Wall -g -std=c11 -Os

hello: hello.o
	$(CC) $(CFLAGS) -o $@ $<
hello.o: hello.c
	$(CC) -o $@ -c $<
```

`$@`：引用当前规则的目标。

`$<`：引用当前规则的第一个依赖。

## 执行构建

```bash
$ make -f MyMakefile
```

如果只想看一下make会执行哪些命令，而不实际执行，则可以使用`-n`选项（或者`--just-print`、`--dry-run`或`--recon`）。

如果makefile文件是默认名称，则只需要在makefile所在位置执行`make`。

make还可以显式指定从某个目标（或某几个目标）开始执行，例如：

```bash
$ make hello.o
```

make没有显式指定目标时，默认从makefile的第一个目标开始执行。

## 注释

构建文件中，以`#`开始的行是注释。但在命令脚本中出现的`#`，不是make的注释（但有可能是shell的注释）。

## 规则

构建文件主要是通过规则来告诉make如何去构建程序的。

规则由三部分组成：目标（target）、依赖（prerequisite）和命令脚本（command script）。

依赖描述了“何时”构建目标，命令脚本则描述了“如何”构建目标。

只要依赖发生了变化（即依赖比目标新），并且该依赖要么不依赖其他依赖，要么它所依赖的依赖没有发生变化，make就会执行相应的命令脚本，以构建目标。如果该依赖所依赖的依赖也发生了变化，则递归地先处理上一级依赖的变化，然后再执行本规则的命令脚本，以构建目标。

规则的一般格式：

```
目标1 [… 目标N]: [依赖1 [… 依赖N]]
	[命令行1
	…
	命令行N]
```

第一个”目标“必须放在本行的开始，左边不能有空白符。

每个命令行都必须以制表符（不能是空格）开始。

注释和空白行会被忽略。

### 命令脚本

命令脚本中的每个命令行都是在一个新的shell实例中单独执行。因此，每个命令都不依赖于其他前面行的命令的副作用。

例如，下面的命令将不会执行`src/`子目录下的`etags`：

```makefile
TAGS:
	cd src/
	etags *.c
```

在尝试构建`TAGS`时，make会在当前目录下执行shell命令`cd src/`。当该命令执行完毕时，make会在一个新的shell实例中执行`etags *.c`，还是在当前目录下。

有两种方式让多个命令在同一个shell下执行：把它们放在一行并用分号隔开它们，或者加上分号和反斜线，让它们逻辑上成为在一行：

```makefile
TAGS:
	cd src/ ; etags *.c ;\
	cd .. ; ls src/TAGS
```

在同一个shell中执行多个命令的另一个原因是可以加快处理速度，特别在大型项目中尤其突出。

### 模式规则

模式规则的一般格式：

```
[目标1 [… 目标N]:] 目标模式 : 依赖模式
	[命令行1
	…
	命令行N]
```

如果包含一个显式的目标列表，则该规则就是静态模式规则。这时，目标列表中的每个目标依次都要匹配目标模式，并且静态模式规则只适用于它的目标列表中的目标。例如：

```makefile
circulararea.o circle.o: %.o: %.c
	$(CC) $(CFLAGS) -o $@ -c $<
```

目标模式中允许出现通配符`%`。当make采用`%.o`模式匹配目标列表中的每个目标时，目标匹配通配符`%`的部分被称为stem（词干）。这个stem会取代`%.c`中的百分号，以生成依赖。

每个模式中只会使用一次通配符。如果想在模式中使用字面意义的百分号，则需要使用`\%`。另外，在模式中`\\`表示字面意义的反斜线。

如果省略目标列表，则该规则被称为隐式规则（implicit rule）。隐式规则适用于任意目标。例如：

```makefile
%.o: %.c
	$(CC) $(CFLAGS) -o $@ -c $<
```

如果一个目标和显式规则（有目标列表的规则）没有命令脚本，make会尝试对该目标使用隐式规则。

对于同一个目标，可能存在许多隐式规则可以匹配它。make会根据哪个依赖有效，或者应用哪个规则可以生成有效的依赖，从隐式规则列表中挑选出第一个规则。

如果make生成了在makefile中没有被提及的任何中间文件，这些中间文件都会在达成相应目标后被删除。

例如：makefile

```makefile
%: %.o
	cc -o $@ $^
%.o: %.c
	cc -c -o $@ $<
```

则，

```bash
$ ls
Makefile square.c
$ make -r square
cc -c -o square.o square.c
cc -o square square.o
rm square.o
$ ls
Makefile square square.c
```

根据目标，make找到了Makefile中的两个隐式规则以及有效的源文件，并采用间接的方法构建了目标，然后自动地清理中间目标文件（`square.o`），因为这个中间文件没有在Makefile或命令行中被提及。

### 内置规则

make为一些常见的操作（例如，将C源代码编译成目标文件）定义了许多内置规则（以及所使用的预定义变量），可以运行`make -p` 命令，它不会构建项目，而只是显示make的内置规则和变量。

自己在makefile中定义的规则优先级高于内置规则。

可以在makefile中重写内置规则和变量。

如果要禁用内置规则，则需要使用`-r`选项：

```bash
$ make -r foo
```

### 目标是链接库成员

大多数程序不仅依赖源代码，还依赖链接库。对于目标是链接库成员的情况，make为这类目标提供一个特殊的表示法：

```makefile
AR = ar -rv

libcircularmath.a(circulararea.o): circulararea.o
	$(AR) $@ $%
```

上述规则将执行下面的命令：

```bash
$ ar -rv libcircularmath.a circulararea.o
```

### 双冒号规则

双冒号规则在目标与依赖之间有两个冒号，而普通规则的目标与依赖之间只有一个冒号。

在同一个makefile中，一个目标可以出现在多个规则中。但是这些规则必须是同一类型的规则，要么都是普通规则，要么都是双冒号规则。而不允许一个目标同时出现在两种不同类型的规则中。

双冒号规则和普通规则的处理的不同点表现在以 下几个方面： 

1.  对于一个没有依赖的双冒号规则，当引用此目标时，规则的命令脚本将会被无条件执行。而普通规则，当规则的目标文件存在时（不是伪目标），此规则的命令脚本永远不会被执行（目标文件永远是最新的）。 
2.  当同一个文件作为多个双冒号规则的目标时，只会选择第一个依赖比目标新的那条规则，其他双冒号规则（不管依赖是否比目标新）将不会执行， 而不是像普通规则那样，选择最后一个依赖比目标新的规则。这就意味着对这些双冒号规则的处理就像多个不同的普通规则一样。

### 伪目标

并非将要生成的文件名的目标，称为伪目标（phony target）。

没有依赖的伪目标，只要被调用，不管是普通规则，还是双冒号规则，它的命令脚本总会被执行。

另外，作为`.PHONY`的依赖的目标总是伪目标，而不管是否存在文件名与它对应。例如：

```makefile
.PHONY: bin
bin: circle
	$(MKDIR) $@
	$(CP) $< $@/
	$(CHMOD) 600 $@/$<
```



## 变量

make中的变量可在多个层次中定义。通过make命令行参数定义的变量优先级最高，而在makefile中定义的变量优先级最低。

可以使用`make -p` 命令来获取所有变量的来源。

### 通过make命令行参数定义

```bash
$ make CFLAGS="-g -Wall"
```

### 通过环境变量定义

在运行make之前从shell中设定环境变量，这样make就可以利用这些变量了。例如：

```bash
$ export CFLAGS='-g -Wall -O3'
```

如果变量定义与要执行的命令在同一行，可以省略`export`：

```bash
$ PANTS=kakhi PLANTS="ficus fern" env | grep 'P.*NTS'
```

这样定义的变量只在当前命令行中可访问，等号两边不要有空格，变量定义要放在命令之前且使用空格分隔，多个变量定义之间也使用空格分隔。

### 在makefile中定义

根据定义的方式不同，变量可以分为递归展开（recursively expanded）变量和简单展开（simply expanded）变量。

#### 递归展开变量

递归展开变量定义可使用`=`运算符：

```makefile
DEBUGFLAGS = $(CFLAGS) -ggdb -DDEBUG -O0
```

递归展开变量`DEBUGFLAGS`的定义体中的引用变量`$(CFLAGS)`，只有在`DEBUGFLAGS`被引用时才会被展开。

#### 简单展开变量

简单展开变量定义可使用`:=`运算符：

```makefile
OBJ = circle.o circulararea.o
TESTOBJ := $(OBJ) profile.o
```

简单展开变量`TESTOBJ`定义体中的引用变量`$(OBJ)`，在定义时就已经展开。这样，后续`OBJ`即使有修改，也不会影响`$(TESTOBJ)`的值。

#### 附加运算符

附加运算符`+=`将更多字符附加到一个变量现有值的后面。

对简单展开变量执行附加运算符后，结果仍是简单展开变量；而对递归展开变量或者尚未定义的变量执行附加运算符后，结果为递归展开变量。

例如：

```makefile
OBJ += profile.o
```

附加运算符在展开新文本到变量现有值时，会自动插入一个空格。

#### 条件赋值运算符

条件赋值运算符`?=`只能给一个尚未定义的变量赋值，如果变量已经存在，则赋值不会起作用。并且条件赋值运算符定义的变量总是递归展开变量。

#### 通过宏定义变量

参见“宏”。

#### 重写变量

在makefile中，可以使用`override`关键字来重写在命令行或shell环境中定义的任何变量：

```makefile
override CPPLFAGS = -DDEBUG
```

#### 目标专用的变量赋值

可以为某个目标定义专用变量：

```makefile
目标列表 : [override] 变量赋值
```

这些目标专用变量或模式专用变量会取代任何其他地方定义的同名变量定义。

一个规则只能定义一个专用变量，如果要对同一目标定义多个专用变量，则要定义多个规则：

```makefile
debug symbols: CFLAGS += $(DEBUGCFLAGS)
symbols: ASMFLAGS = -Wa,-as=$*.sm,-L
```

### 引用变量

变量名称如果包含多个字符，则在命令脚本引用时，必须使用`$(变量名)`形式引用；如果变量名只有一个字符，则可采用`$变量名`形式引用。

> 这与在shell中引用变量不同，在shell中不管变量名是一个字符，还是多个字符，都是采用`$变量名`形式。

#### 替换引用

例如：引用变量`$(OBJ)`的值中所有以`.o`结尾单词的结尾部分`.o`替换为`.sym`。

```makefile
SYMTABS = $(OBJ: .o = .sym)
```

### 内置变量

`$@`：当前目标。

`$*`：模式规则中`%`所代表部分。

`$<`：第一个依赖。

`$^`：依赖列表，排除了重复的元素。

`$?`：比目标新的依赖列表。

`$+`：依赖完整列表，包括重复的元素。

`$%`：如果目标是一个链接库成员，变量`$%` 是链接库成员名，而`$@`是链接库文件名。

上述内置变量还可以跟上`D`或`F`后缀。例如，`$(@D)`展开为目标的目录部分（不包含文件名），而`$(@F)`展开为目标的文件名（不包含目录）。

## 宏

宏与变量之间没有实质的差别。宏通常用于定义包括多行的变量。

宏的一般形式：

```makefile
define 宏名
宏值
endef
```

例如：

```makefile
define installtarget
@echo Installing $@ in $(USRBINDIR) ... ;\
$(MKDIR) -m 7700 $(USRBINDIR);\
$(CP) $@ $(USRBINDIR)/ ;\
@echo ... done.
endef
```

引用宏的语法与引用变量相同，例如：

```makefile
circle: $(OBJ) $(LIB)
	$(CC) $(LDFLAGS) -o $@ $^
ifdef INSTALLTOO
	$(installtarget)
endif
```

## 函数

### 内置函数

### 自定义函数

可以使用`define` 命令和`:=` 赋值运算符来自定义函数，类似于变量或宏。

函数体中可以包含带编号的形参引用。例如，`$1`表示第一个参数、`$2`表示第二个参数等等。

```makefile
# 一个条件式的赋值作为提醒，用户可能在命令行定义“STATIC=1”或“STATIC=yes”
STATIC ?=

# 一个生成库模块名的函数
define getmodulename
	$(if $2, $1, $(addsuffix .so, $(basename $1)))
endef

all: circle

circle: circle.o $(call getmodulename, circulararea.o, $(STATIC))
	$(CC) -o $@ $^
	
ifndef STATIC
%.so: %.o
	$(CC) -shared -o $@ $<
endif
```

### 函数调用

内置函数调用的一般格式：

```makefile
$(内置函数名 参数1[, …, 参数N])
```

自定义函数调用的一般格式：

```makefile
$(call 自定义函数名[, 参数1, …, 参数N])
```

> `call`是一个内置函数。

## 指令

### 条件

没有定义的变量与定义成空的变量是相同的含义。

`ifdef`

`ifndef`

`ifeq`

`ifneq`

### include

### override

### export/unexport

### vpath

## CMake

在 linux 平台下使用 CMake 生成 Makefile 并编译的流程如下：

1. 编写 CMake 配置文件 `CMakeLists.txt` 。
2. 执行命令 `cmake PATH` 或者 `ccmake PATH` 生成本地化的 `makefile`文件。其中， `PATH` 是 `CMakeLists.txt` 文件所在的目录。`ccmake` 和 `cmake` 的区别在于前者提供了一个交互式的界面。
3. 使用 `make` 命令进行编译。

# 程序剖析

使用GCC的`-p`选项会在程序中加入一些特殊的函数，以当执行程序时输出剖析信息（profiling information）。剖析信息相当有用，可以辅助解决性能相关的问题，因为它可以帮助了解程序中哪些函数正在耗费时间。剖析信息被存储到一个名为`mon.out`的文件中。然后可以使用prof工具程序来以多种方式来分析剖析信息。

在编译程序时可以使用`-pg`选项启用它。剖析信息输出的默认文件名是`gmon.out` 。GNU剖析器（profiler）gprof结合GCC选项`-pg`使用，可以生成一张调用图，显示程序内函数间是如何相互调用的。如果`-pg`选项结合选项`-g`使用，GCC选项就会为调试器提供源代码行号信息，并且gprof也可以提供逐行的剖析信息。